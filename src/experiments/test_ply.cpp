#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include "tinyply.h"
#include <cmath>

struct Vec3 {
    double x, y, z;

    Vec3() : x(0.0), y(0.0), z(0.0) { }
    Vec3(double x, double y, double z) : x(x), y(y), z(z) { }

    static Vec3 from_spherical(double radius, double theta, double phi) {
        return {
            radius * std::sin(phi) * std::cos(theta),
            radius * std::cos(phi),
            radius * std::sin(phi) * std::sin(theta)
        };
    }
};

struct Mesh {
    std::vector<Vec3> vertices;
    std::vector<Vec3> normals;
    std::vector<std::array<uint32_t, 3>> indices;
};

class SphereGenerator {
 public:
    SphereGenerator(int stacks, int slices, double radius) : stacks(stacks), slices(slices), radius(radius) {}
    void generate();
    void save_ply(const std::string &filename) const;

 private:
    int stacks;
    int slices;
    double radius;
    Mesh mesh;
    static std::vector<uint32_t> flatten(const std::vector<std::array<uint32_t, 3>> &indices) ;
};

int main() {
    const int stacks = 10;
    const int slices = 20;
    const double radius = 1.0;
    const char* filename = "sphere.ply";

    SphereGenerator generator = SphereGenerator(stacks, slices, radius);
    generator.generate();
    generator.save_ply(filename);

    return 0;
}

void SphereGenerator::generate() {
    for (int stack = 0; stack <= stacks; ++stack) {
        double phi = static_cast<double>(stack) * M_PI / static_cast<double>(stacks);

        for (int slice = 0; slice <= slices; ++slice) {
            double theta = static_cast<double>(slice) * 2.0 * M_PI / static_cast<double>(slices);

            Vec3 vertex = Vec3::from_spherical(radius, theta, phi);
            Vec3 normal = {vertex.x / radius, vertex.y / radius, vertex.z / radius};

            mesh.vertices.push_back(vertex);
            mesh.normals.push_back(normal);
        }
    }

    for (int stack = 0; stack < stacks; ++stack) {
        for (int slice = 0; slice < slices; ++slice) {
            uint32_t first = (stack * (slices + 1)) + slice;
            uint32_t second = first + slices + 1;

            mesh.indices.push_back({first, second, first + 1});
            mesh.indices.push_back({second, second + 1, first + 1});
        }
    }
}

void SphereGenerator::save_ply(const std::string &filename) const {
    tinyply::PlyFile sphere_file;

    sphere_file.add_properties_to_element("vertex", {"x", "y", "z"},
        tinyply::Type::FLOAT64, mesh.vertices.size(),
        reinterpret_cast<const uint8_t *>(mesh.vertices.data()), tinyply::Type::INVALID, 0
    );

    sphere_file.add_properties_to_element("vertex", {"nx", "ny", "nz"},
        tinyply::Type::FLOAT64, mesh.normals.size(),
        reinterpret_cast<const uint8_t *>(mesh.normals.data()), tinyply::Type::INVALID, 0
    );

    std::vector<uint32_t> flattened_indices = flatten(mesh.indices);

    sphere_file.add_properties_to_element("face", {"vertex_indices"},
        tinyply::Type::UINT32, mesh.indices.size(),
        reinterpret_cast<const uint8_t *>(flattened_indices.data()), tinyply::Type::UINT8, 3
    );

    sphere_file.get_comments().emplace_back("generated by tinyply 2.3");

    std::ofstream outstream_ascii(filename, std::ios::binary);
    if (outstream_ascii.is_open()) {
        sphere_file.write(outstream_ascii, false);
        std::cout << "PLY file " << filename << " generated successfully." << std::endl;
    } else {
        std::cerr << "Failed to open the output file: " << filename << std::endl;
    }
}
std::vector<uint32_t> SphereGenerator::flatten(const std::vector<std::array<uint32_t, 3>> &indices) {
    std::vector<uint32_t> flattened_indices;

    for (const auto &face : indices) {
        flattened_indices.insert(flattened_indices.end(), face.begin(), face.end());
    }

    return flattened_indices;
}
