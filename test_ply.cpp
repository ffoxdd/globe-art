#include <iostream>
#include <vector>
#include <array>
#include <fstream>
#include "tinyply.h"
#include <cmath>

struct Vec3 {
    double x, y, z;
    Vec3() : x(0.0), y(0.0), z(0.0) { }
    Vec3(double x, double y, double z) : x(x), y(y), z(z) { }
};

struct Mesh {
    std::vector<Vec3> vertices;
    std::vector<Vec3> normals;
    std::vector<std::array<uint32_t, 3>> indices;
};

Mesh generate_sphere(int stacks, int slices, double radius) {
    Mesh mesh;

    for (int stack = 0; stack <= stacks; ++stack) {
        double phi = static_cast<double>(stack) * M_PI / static_cast<double>(stacks);

        for (int slice = 0; slice <= slices; ++slice) {
            double theta = static_cast<double>(slice) * 2.0 * M_PI / static_cast<double>(slices);

            Vec3 vertex{
                radius * std::sin(phi) * std::cos(theta),
                radius * std::cos(phi),
                radius * std::sin(phi) * std::sin(theta)
            };

            Vec3 normal = {vertex.x / radius, vertex.y / radius, vertex.z / radius};

            mesh.vertices.push_back(vertex);
            mesh.normals.push_back(normal);
        }
    }

    for (int stack = 0; stack < stacks; ++stack) {
        for (int slice = 0; slice < slices; ++slice) {
            uint32_t first = (stack * (slices + 1)) + slice;
            uint32_t second = first + slices + 1;

            mesh.indices.push_back({first, second, first + 1});
            mesh.indices.push_back({second, second + 1, first + 1});
        }
    }

    return mesh;
}

void save_ply(const Mesh &mesh, const std::string &filename) {
    tinyply::PlyFile sphere_file;

    sphere_file.add_properties_to_element("vertex", {"x", "y", "z"},
        tinyply::Type::FLOAT64, mesh.vertices.size(),
        reinterpret_cast<const uint8_t *>(mesh.vertices.data()), tinyply::Type::INVALID, 0
    );

    sphere_file.add_properties_to_element("vertex", {"nx", "ny", "nz"},
        tinyply::Type::FLOAT64, mesh.normals.size(),
        reinterpret_cast<const uint8_t *>(mesh.normals.data()), tinyply::Type::INVALID, 0
    );

    // Flatten the indices for tinyply
    std::vector<uint32_t> flattened_indices;
    for (const auto &face : mesh.indices) {
        flattened_indices.insert(flattened_indices.end(), face.begin(), face.end());
    }

    sphere_file.add_properties_to_element("face", {"vertex_indices"},
        tinyply::Type::UINT32, mesh.indices.size(),
        reinterpret_cast<const uint8_t *>(flattened_indices.data()), tinyply::Type::UINT8, 3
    );

    sphere_file.get_comments().emplace_back("generated by tinyply 2.3");

    std::ofstream outstream_ascii(filename, std::ios::binary);
    if (outstream_ascii.is_open()) {
        sphere_file.write(outstream_ascii, false);
        std::cout << "PLY file " << filename << " generated successfully." << std::endl;
    } else {
        std::cerr << "Failed to open the output file: " << filename << std::endl;
    }
}

int main() {
    int stacks = 10;
    int slices = 20;
    double radius = 1.0;

    Mesh mesh = generate_sphere(stacks, slices, radius);
    save_ply(mesh, "sphere.ply");

    return 0;
}
